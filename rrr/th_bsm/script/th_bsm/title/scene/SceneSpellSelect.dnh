#include "../lib/SpellData.dnh"
#include "../../lib/effect/lib_EffectLib.dnh"
// リザルト用
#include "./../../lib/lib_result.dnh"

// ステージ選択画面
function SceneSpellSelect(selectedDedault)
{
	let d1 = selectedDedault;
	let d2 = 0;
	let d3 = 0;
	let d4 = 0;
	let d5 = 0;

	//自動選択
	let tmpMemory = CheckMenuMemory();
	let tmpMemory2 = CheckMenuMemory();
	let tmpMemory3 = CheckMenuMemory();
	if (tmpMemory >= 0 && tmpMemory2 >= 0 && tmpMemory3 >= 0)
	{
		d1 = tmpMemory;
		d2 = tmpMemory2;
		d3 = tmpMemory3;
		d4 = 1;
	}
	
	let objParent = ObjText_Create();	//適当なオブジェクトを生成（データのやり取り用）
	Obj_SetValue(objParent, "VALUE", d1);	// ステージ
	Obj_SetValue(objParent, "VALUE2", d2);	// 右画面選択位置
	Obj_SetValue(objParent, "VALUE2b", d5);	//選択位置オフセット
	Obj_SetValue(objParent, "VALUE_D", d3);	//難易度
	Obj_SetValue(objParent, "VALUE_X", d4);	//メニュー階層（ステージ選択orスペカ選択）

	let selectMax = STAGE_MAX;
	let diffMax = 4;
	let resultIndex = -1;
	let resultIndexD = -1;
	
	let flgResetMenu = true;
	let SLIST = [];
	let SLIST_Data = [];
	let selectMax2 = length(SLIST);
	let viewMax2 = 8;

	//メニュー配置
TMenuItemInfo(objParent, 16, 420, gettxt("SceneSpellSelect.dnh.1",GetAreaCommonData("Config", "AccKey", 0)));
	TMenuItemDifficult(objParent, 120, 104);
	ascent(i in 0 .. selectMax)
	{
		let base_x = 90 - i*8;
		let base_y = 130 + i*32;
		
		TMenuItemText(objParent, i, base_x, base_y, STAGE_NAME[i]);
	}
	wait(10);
	//キー状態がリセットされるまで待機
	WaitForResetKeyEx([VK_OK, VK_CANCEL]);

	loop
	{
		if (flgResetMenu)
		{
			flgResetMenu = false;
			CheckDifficulty();

			SLIST = GetSpellCardList( Obj_GetValueD(objParent, "VALUE", 0), Obj_GetValueD(objParent, "VALUE_D", 0) );
			SLIST_Data = [];
			selectMax2 = length(SLIST);
			if (selectMax2 <= 0)
			{
				// メニューを戻る
				Obj_SetValue(objParent, "VALUE_X", 0);
			}
			else
			{
				// 選択位置補正
				Obj_SetValue(objParent, "VALUE2", min(selectMax2-1, max(0, Obj_GetValueD(objParent, "VALUE2", -1))));
				
				//メニュー配置
				let tmpDifficulty	= Obj_GetValueD(objParent, "VALUE_D", 0);
				
				// 文字用
				TMenuItemSpellImage(objParent, 210+350, 150-20-12,  0, 24, 32, 34);
				TMenuItemSpellImage(objParent, 210+350, 150-20, 32, 24, 64, 34);
				
				ascent(i in 0 .. selectMax2)
				{
					// リザルトロード
					let sID = GetSpellCardIDEx( SLIST[i], tmpDifficulty );
					let flg = LoadResult( GetSpellCardIndex(sID) );
					SLIST_Data = SLIST_Data ~ [flg];

					TMenuItemSpell(objParent, i, 210, 150, -8, 32, GetSpellCardName(SLIST[i], tmpDifficulty), flg);
				}
			}
		}

		//キー入力待ち
		let downKey = CheckKey_MenuEx(30, 6, [VK_UP, VK_DOWN, VK_LEFT, VK_RIGHT, VK_CANCEL, VK_OK]);
		
		alternative (downKey)
		case (VK_UP)
		{
			CallSoundPackage(sndTtSelect);
			if (!Obj_GetValueD(objParent, "VALUE_X", 0))
				{ Menu_AddValue(objParent, "VALUE", -1, selectMax); flgResetMenu = true; }
			else
			{
				Menu_AddValue(objParent, "VALUE2", -1, selectMax2);
				if (selectMax2 < viewMax2)
				{
					Obj_SetValue(objParent, "VALUE2b", 0);
				}
				else
				{
					let tmp2 = Obj_GetValueD(objParent, "VALUE2", 0);
					let tmp2b = Obj_GetValueD(objParent, "VALUE2b", 0);
					let tmp = tmp2b;
					if (tmp2+tmp2b < 0) { tmp = -(tmp2); }
					else if (tmp2+tmp2b > viewMax2-1) { tmp = -(tmp2-viewMax2+1); }
					Obj_SetValue(objParent, "VALUE2b", tmp);
				}
			}
			CheckDifficulty();
		}
		case (VK_DOWN)
		{
			CallSoundPackage(sndTtSelect);
			if (!Obj_GetValueD(objParent, "VALUE_X", 0))
				{ Menu_AddValue(objParent, "VALUE", 1, selectMax); flgResetMenu = true; }
			else
			{
				Menu_AddValue(objParent, "VALUE2", 1, selectMax2);
				if (selectMax2 < viewMax2)
				{
					Obj_SetValue(objParent, "VALUE2b", 0);
				}
				else
				{
					let tmp2 = Obj_GetValueD(objParent, "VALUE2", 0);
					let tmp2b = Obj_GetValueD(objParent, "VALUE2b", 0);
					let tmp = tmp2b;
					if (tmp2+tmp2b < 0) { tmp = -(tmp2); }
					else if (tmp2+tmp2b > viewMax2-1) { tmp = -(tmp2-viewMax2+1); }
					Obj_SetValue(objParent, "VALUE2b", tmp);
				}
			}
			CheckDifficulty();
		}
		case (VK_LEFT)
		{
			CallSoundPackage(sndTtSelect);
			Menu_AddValue(objParent, "VALUE_D", -1, diffMax);
			CheckDifficulty();
			flgResetMenu = true;
		}
		case (VK_RIGHT)
		{
			CallSoundPackage(sndTtSelect);
			Menu_AddValue(objParent, "VALUE_D", 1, diffMax);
			CheckDifficulty();
			flgResetMenu = true;
		}
		case (VK_CANCEL)
		{
			CallSoundPackage(sndTtCancel);
			if (Obj_GetValueD(objParent, "VALUE_X", 0))
			{
				Obj_SetValue(objParent, "VALUE_X", 0);
				WaitForResetKeyEx([VK_OK, VK_CANCEL]);
			}
			else
			{
				break;
			}
		}
		case (VK_OK)
		{
			if (Obj_GetValueD(objParent, "VALUE_X", 0))
			{
				if ( SLIST_Data[Obj_GetValueD(objParent, "VALUE2", 0)][4] )
				{
					MenuEnter(objParent, "FLASH2");

					resultIndex = SLIST[Obj_GetValueD(objParent, "VALUE2", 0)];
					resultIndexD = Obj_GetValueD(objParent, "VALUE_D", 0);

					break;
				}
				else
				{
					CallSoundPackage(sndTtCancel);
				}
			}
			else if (selectMax2 <= 0)
			{
				CallSoundPackage(sndTtCancel);
			}
			else
			{
				MenuEnter(objParent, "FLASH");
				Obj_SetValue(objParent, "VALUE_X", 1);
				WaitForResetKeyEx([VK_OK, VK_CANCEL]);
			}
		}
		wait(2);	//適当に固定ディレイ
	}

	d1 = Obj_GetValueD(objParent, "VALUE", 0);
	d2 = Obj_GetValueD(objParent, "VALUE2", 0);
	d3 = Obj_GetValueD(objParent, "VALUE_D", 0);
	Obj_Delete(objParent);
	
	// 前半2つは次のスクリプトに渡す値、最後の3つは選択肢保存用
	return([resultIndex, resultIndexD,
		d1, d2, d3]);
	
	// メニュー選択時モーション
	function MenuEnter(parent, ftype)
	{
		CallSoundPackage(sndTtDecide);
		Obj_SetValue(parent, ftype, 1);
		wait(12);
		Obj_SetValue(parent, ftype, 0);
	}
	task TMenuItemInfo(parent, base_x, base_y, text)
	{
		let objText = SetSystemText(base_x, base_y, text);
		ObjRender_SetColor(objText, 255, 255, 255);
		ObjText_SetFontSize(objText, 18);
		
		let alpha = 0;
		while(!Obj_IsDeleted(parent))
		{
			yield;
		}
		descent(t in 0 .. 10)
		{
			let alpha = 255*((t+1)/10);
			ObjRender_SetAlpha(objText, alpha);
			yield;
		}
		Obj_Delete(objText);
	}
	task TMenuItemText(parent, index, base_x, base_y, text)
	{
		let objText = SetSystemText(base_x, base_y, text);
		ObjRender_SetColor(objText, 120, 120, 160);
		ObjText_SetFontSize(objText, 32);
		let objTextS = SetSystemText(base_x, base_y, text);
		ObjRender_SetBlendType(objTextS, BLEND_ADD_ARGB);
		Obj_SetVisible(objTextS, false);
		ObjText_SetFontSize(objTextS, 32);
		ObjRender_SetColor(objTextS, 255, 255, 96);
		
		let alpha = 0;
		let before_index = -99999;
		let t = 0;
		while(!Obj_IsDeleted(parent))
		{
			let selected_index = Obj_GetValueD(parent, "VALUE", -1);
			if (selected_index != before_index)
			{
				Obj_SetVisible(objTextS, (selected_index==index));
				before_index = selected_index;
			}
			if (selected_index==index && Obj_GetValueD(parent, "FLASH", 0))
			{
				Obj_SetVisible(objTextS, (t%6>3));
				t++;
			}
			if (alpha < 1)
			{
				alpha = min(1, 0.1+alpha);
			}
			if (Obj_GetValueD(objParent, "VALUE_X", 0))
			{
				ObjRender_SetAlpha(objText, 96*alpha);
				ObjRender_SetAlpha(objTextS, 128*alpha);
			}
			else
			{
				ObjRender_SetAlpha(objText, 255*alpha);
				ObjRender_SetAlpha(objTextS, 255*alpha);
			}
			yield;
		}
		descent(t in 0 .. 10)
		{
			let alpha = 255*((t+1)/10);
			ObjRender_SetAlpha(objText, alpha);
			ObjRender_SetAlpha(objTextS, alpha);
			yield;
		}
		Obj_Delete(objText);
		Obj_Delete(objTextS);
	}
	task TMenuItemDifficult(parent, base_x, base_y)
	{
		let d_index = [0, 1, 2, 3, 4];
		
		let objText = ObjPrim_Create(OBJ_SPRITE_2D);
		Obj_SetRenderPriorityI(objText, 80);
		ObjPrim_SetTexture(objText, imgTtSpellRank);
		ObjRender_SetPosition(objText, base_x, base_y, 0);
		
		let alpha = 0;
		let before_index = -99999;
		let before_index2 = -99999;
		while(!Obj_IsDeleted(parent))
		{
			let new_index = Obj_GetValueD(objParent, "VALUE_D", -1);
			let new_index2 = Obj_GetValueD(objParent, "VALUE", -1);
			if (before_index != new_index || before_index2 != new_index2)
			{
				let idx = new_index;
				ObjSprite2D_SetSourceRect(objText, 0, d_index[idx]*32, 128, (d_index[idx]+1)*32);
				ObjSprite2D_SetDestCenter(objText);
				before_index = new_index;
				before_index2 = new_index2;
			}
			if (alpha < 1)
			{
				alpha = min(1, 0.1+alpha);
				ObjRender_SetAlpha(objText, 255*alpha);
			}
			yield;
		}
		descent(t in 0 .. 10)
		{
			let alpha = 255*((t+1)/10);
			ObjRender_SetAlpha(objText, alpha);
			yield;
		}
		Obj_Delete(objText);
	}
	task TMenuItemSpell(parent, index, base_x, base_y, add_x, add_y, text, spellFlgs)
	{
		let isVisible = spellFlgs[4];
		let isTyousen = (isVisible && spellFlgs[0] <= 0 && spellFlgs[2] <= 0);
		let eff_x = base_x + add_x*index;
		let eff_y = base_y + add_y*index;
		
		if (!isVisible) { text = "(未確認のスペルカード)"; }
		else if (isTyousen) { text = "＊挑戦者求む！"; }
		
		let objText = SetSystemText(eff_x, eff_y, text);
		if (isVisible) { ObjRender_SetColor(objText, 120, 120, 160); }
		else { ObjRender_SetColor(objText, 64, 64, 64); }
		ObjText_SetFontSize(objText, 26);
		
		let objTextS = SetSystemText(eff_x, eff_y, text);
		ObjRender_SetBlendType(objTextS, BLEND_ADD_ARGB);
		Obj_SetVisible(objTextS, false);
		ObjText_SetFontSize(objTextS, 26);
		if (isVisible) { ObjRender_SetColor(objTextS, 255, 255, 96); }
		else { ObjRender_SetColor(objTextS, 96, 96, 96); }
		
		//リザルト
		let objNumber = [ObjPrim_Create(OBJ_PRIMITIVE_2D), ObjPrim_Create(OBJ_PRIMITIVE_2D)];
		if (isVisible)
		{
			ascent(i in 0 .. 2)
			{
				let resultFlg = [1, 0];
				if (i == 1) { resultFlg = [3, 2]; }
				
				ObjPrim_SetTexture(objNumber[i], imgTtMiniNumber);
				ObjPrim_SetPrimitiveType(objNumber[i], PRIMITIVE_TRIANGLELIST);
				ObjPrim_SetVertexCount(objNumber[i], (3*2+1)*6);
				Obj_SetRenderPriorityI(objNumber[i], 90);
				ObjRender_SetPosition(objNumber[i], eff_x+320, eff_y+i*12, 0);
				local
				{
					let offset_x = 0;
					ascent(iObj in 0 .. 7)
					{
						SetPrimMiniNumber_Base(objNumber[i], iObj, offset_x, 0);
						offset_x += 6;
					}
					SetPrimMiniNumber(objNumber[i], 3, 11);

					let listNum = DigitToArray(min(999, spellFlgs[resultFlg[0]]), 3);
					ascent(iObj in 0 .. 3)
					{
						SetPrimMiniNumber(objNumber[i], iObj, listNum[iObj]);
					}
					let listNum2 = DigitToArray(min(999, spellFlgs[resultFlg[1]]), 3);
					ascent(iObj in 0 .. 3)
					{
						SetPrimMiniNumber(objNumber[i], iObj+4, listNum2[iObj]);
					}

				}
			}
			if (spellFlgs[1] > 0)
				{ ObjRender_SetColor(objNumber[0], 255, 255, 64); }
			else
				{ ObjRender_SetColor(objNumber[0], 96, 96, 96); }
			if (spellFlgs[3] > 0)
				{ ObjRender_SetColor(objNumber[1], 255, 160, 64); }
			else
				{ ObjRender_SetColor(objNumber[1], 96, 96, 96); }
		}

		
		let alpha = 1;
		let before_index = -99999;
		let before_index2 = -99999;
		let t = 0;
		while(!Obj_IsDeleted(parent))
		{
			// 選択変更
			let selected_index = Obj_GetValueD(parent, "VALUE2", -1);
			if (selected_index != before_index)
			{
				Obj_SetVisible(objTextS, (selected_index==index));
				before_index = selected_index;
			}
			// メニュー位置ずらし
			let selected_index2 = Obj_GetValueD(parent, "VALUE2b", -1);
			if (selected_index2 != before_index2)
			{
				let tmp_index = index + selected_index2;
				eff_x = base_x + add_x*tmp_index;
				eff_y = base_y + add_y*tmp_index;
				ObjRender_SetPosition(objText, eff_x, eff_y, 0);
				ObjRender_SetPosition(objTextS, eff_x, eff_y, 0);
				ObjRender_SetPosition(objNumber[0], eff_x+320, eff_y, 0);
				ObjRender_SetPosition(objNumber[1], eff_x+320, eff_y+12, 0);
				
				alpha = 1;
				if (tmp_index < 0) { alpha = 0; }
				else if (tmp_index >= viewMax2-1) { alpha -= (tmp_index-viewMax2+1)*0.5; }
				if (alpha < 0) { alpha = 0; }

				before_index2 = selected_index2;
			}
			
			/*
			if (alpha < 1)
			{
				alpha = min(1, 0.2+alpha);
			}
			*/
			if (selected_index==index && Obj_GetValueD(parent, "FLASH2", 0))
			{
				Obj_SetVisible(objTextS, (t%6>3));
				t++;
			}
			if (flgResetMenu)
			{
				break;
			}
			if (Obj_GetValueD(objParent, "VALUE_X", 0))
			{
				ObjRender_SetAlpha(objText, 255*alpha);
				ObjRender_SetAlpha(objTextS, 255*alpha);
				ascent(i in 0 .. 2) { ObjRender_SetAlpha(objNumber[i], 255*alpha); }
			}
			else
			{
				ObjRender_SetAlpha(objText, 128*alpha);
				ObjRender_SetAlpha(objTextS, 0*alpha);
				ascent(i in 0 .. 2) { ObjRender_SetAlpha(objNumber[i], 128*alpha); }
			}
			yield;
		}
		descent(t in 0 .. 5)
		{
			let tmp = ((t+1)/5);
			if (Obj_GetValueD(objParent, "VALUE_X", 0))
			{
				ObjRender_SetAlpha(objText, tmp*255*alpha);
				ObjRender_SetAlpha(objTextS, tmp*255*alpha);
				ascent(i in 0 .. 2) { ObjRender_SetAlpha(objNumber[i], tmp*255*alpha); }
			}
			else
			{
				ObjRender_SetAlpha(objText, tmp*128*alpha);
				ObjRender_SetAlpha(objTextS, tmp*0*alpha);
				ascent(i in 0 .. 2) { ObjRender_SetAlpha(objNumber[i], tmp*128*alpha); }
			}
			yield;
		}
		Obj_Delete(objText);
		Obj_Delete(objTextS);
		ascent(i in 0 .. 2) { Obj_Delete(objNumber[i]); }
	}
	task TMenuItemSpellImage(parent, base_x, base_y, x1, y1, x2, y2)
	{
		let objText = ObjPrim_Create(OBJ_SPRITE_2D);
		Obj_SetRenderPriorityI(objText, 80);
		ObjPrim_SetTexture(objText, imgTtMiniNumber);
		ObjSprite2D_SetSourceRect(objText, x1, y1, x2, y2);
		ObjSprite2D_SetDestRect(objText, trunc(-(x2-x1)/2), 0, trunc((x2-x1)/2), y2-y1);
		ObjRender_SetPosition(objText, base_x, base_y, 0);
		
		let alpha = 0;
		while(!Obj_IsDeleted(parent))
		{
			if (flgResetMenu)
			{
				break;
			}
			if (alpha < 1)
			{
				alpha = min(1, 0.2+alpha);
			}
			if (Obj_GetValueD(objParent, "VALUE_X", 0))
			{
				ObjRender_SetAlpha(objText, 255*alpha);
			}
			else
			{
				ObjRender_SetAlpha(objText, 128*alpha);
			}
			yield;
		}
		descent(t in 0 .. 5)
		{
			let tmp = ((t+1)/5);
			if (Obj_GetValueD(objParent, "VALUE_X", 0))
			{
				ObjRender_SetAlpha(objText, tmp*255*alpha);
			}
			else
			{
				ObjRender_SetAlpha(objText, tmp*128*alpha);
			}
			yield;
		}
		Obj_Delete(objText);
	}
	// チェック
	function CheckDifficulty()
	{
		let tmp = Obj_GetValueD(objParent, "VALUE", 0);
		let tmp_d = Obj_GetValueD(objParent, "VALUE_D", 0);
		// 主にExtra用
		if (tmp == FLAG_EXTRA && tmp_d != 4)
		{
			Obj_SetValue(objParent, "VALUE_D_tmp", tmp_d);
			Obj_SetValue(objParent, "VALUE_D", 4);
		}
		else if (tmp != FLAG_EXTRA && tmp_d == 4)
		{
			Obj_SetValue(objParent, "VALUE_D", Obj_GetValueD(objParent, "VALUE_D_tmp", 0));
		}
	}
}



